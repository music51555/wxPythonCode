**协程：**

实现在一个进程或线程中，启动多个任务，并使CPU在多个任务间进行切换，并记录状态，由用户自己控制CPU调度

基于单线程，实现并发，在单线程中遇到IO阻塞，或计算时间过长，以遇到优先级更高的程序时，CPU会切换到其他任务上

1、如何实现最简单的任务切换，通过串行执行任务

```python
import time

def product():
    data_list = []
    for i in range(10000000):
        data_list.append(i)
    return data_list

def customer(data_list):
    print(data_list)

start_time = time.time()
res = product()
customer(res)
end_time = time.time()
#3.286834955215454秒
print(end_time - start_time)
```



2、通过yield切换任务

```python
import time

def product():
    g = customer()
    next(g)
    for i in range(10000000):
        g.send(i)
        #此时进行IO操作，当遇到IO操作时，并没有切换到其他任务上去，没有实现单线程内实现并发
        time.sleep(2)

def customer():
    while True:
        x = yield

start_time = time.time()
product()
end_time = time.time()
#1.4196021556854248秒
print(end_time - start_time)
```




**所以，协程的本质就是在单线程下，由用户自己控制，当一个任务遇到io阻塞时，就切换到另外一个任务上去执行，以此来提升效率**



**操作系统控制的是内核级别**的进程切换，当任务遇到IO阻塞时，操作系统来进行切换
**协程是建立在应用程序级别**的进程切换，当应用程序遇到IO阻塞是，在代码级别，由程序员来实现切换到其他任务上去执行



**协程的优点：**

1、单线程内实现并发，即多个任务间的切换

2、协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级

**协程的缺点：**


1. 协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程
2. 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程



**greenlet模块：**

通过greenlet模块，可以实现在函数内切换到其他方法中，但是仍然是没有解决遇到IO自动切换来提升效率的问题

```python
from greenlet import greenlet

def eat(name):
    print('%s is eat1'%name)
    #切换到g2对象的play方法
    g2.switch('alex')
    print('%s is eat2'%name)
    g2.switch('alex')

def play(name):
    print('%s is play1'%name)
    #切换到g1对象的eat方法
    g1.switch('alex')
    print('%s is play2'%name)

if __name__ == '__main__':
    g1 = greenlet(eat)
    g2 = greenlet(play)
	#switch相当于执行哪个对象的方法
    g1.switch('alex')
```



**gevent模块：**

```python
import gevent
def eat(name):
    print('%s eat 1' %name)
    gevent.sleep(2)
    print('%s eat 2' %name)

def play(name):
    print('%s play 1' %name)
    gevent.sleep(1)
    print('%s play 2' %name)


g1=gevent.spawn(eat,'egon')
g2=gevent.spawn(play,name='egon')
g1.join()
g2.join()
#或者gevent.joinall([g1,g2])
print('主')
```


进程：正在执行的过程或任务，CPU负责

1、应用程序的使用，是通过操作系统来调用封装的硬件接口

2、管理操作系统中启动的多个进程

1401，读取程序员的卡片代码，以及打印出程序的结果

7094，处理、计算程序代码

多道技术，

空间的复用：内存中可以同时存储多个程序

时间的复用：

1、在一个程序执行I/O操作的时候，CPU不等待，去执行另一个程序的操作，看似好像同时在运行多个程序，是因为CPU处理各个程序的速度很快，在多个程序间切换的很快

2、应用程序运行时间过长了，或有优先级高的程序在调用CPU，这是CPU会切换程序，在切换程序前会记录程序的状态

每个程序的内存是相互独立的，当程序执行完毕后，会在内存中被清理掉

并发：看起来像同时执行，但是在单核中是因为CPU来回切换程序

并行：在多核的CPU中，同时执行程序

创建一个进程，由应用程序发起，告知操作系统：

1、unix系统是fork，创建子进程时，把父进程的数据内容完整拷贝给子进程，和父进程一样

2、windows系统是creatrpocess，创建子进程时，父进程也会拷贝数据，但内容不一样

进程的状态：

1、运行，占用CPU

2、阻塞，遇到IO操作，或优先级更高的程序使用CPU，运行时间过长

3、就绪，时刻准备着被执行

```python
#开启子进程的方式一，通过创建Process对象的方式实现
import time

from multiprocessing import Process

def task(name):
    print('%s is running'%name)
    time.sleep(2)
    print('%s is done'%name)

if __name__ == '__main__':
    #也可以在创建Process对象的时候使用字典的形式传入参数
    #p = Process(target = task,kwargs = {'name':'子进程1'})
    p = Process(target = task,args = ('子进程1',))
    p.start()
    
    print('主')
```

```python
#开启子进程的方式二，通过继承Process类实现
import time
from multiprocessing import Process

class MyProcess(Process):
    def __init__(self,name):
        super(MyProcess,self).__init__()
        self.name = name

    #方法名必须写为run
    def run(self):
        print('%s is running'%self.name)
        time.sleep(2)
        print('%s is done'%self.name)

if __name__ == '__main__':
    p = MyProcess('子进程1')
    #start本质调用的就是绑定方法run
    p.start()

    print('主')
    
#打印 在执行主进程的过程中也执行了子进程:
#主 
#子进程1 is running
#子进程1 is done
```





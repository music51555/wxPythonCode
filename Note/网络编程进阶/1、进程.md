进程：正在执行的过程或任务，负责执行任务的是cpu

操作系统也是一个软件，是协调、管理和控制计算机软硬件资源的程序

**操作系统的作用：**

1、应用程序的使用，是通过操作系统来调用封装的硬件接口

2、管理、调度系统中启动的多个进程



**多道技术**

针对单核CPU，实现伪并发

**空间的复用：**内存中可以同时存储多个应用的数据

**时间的复用：**

1、在一个程序执行I/O操作的时候，CPU不会一直等待程序处理，而是去处理另一个程序的操作，看似好像同时在运行多个程序，是因为CPU处理各个程序的速度很快，在多个程序间切换的很快

2、应用程序运行时间过长了，CPU会切换程序，在切换程序前会记录程序的状态，保证了在切换回应用程序时，可以继续上次切换的状态

3、有较高优先级的程序时，CPU会切换程序

每个程序的内存是相互独立的，当程序执行完毕后，会在内存中被清理掉

在多核的CPU中，每个核心都有多道技术，当核心占满时，其他应用程序需要等到其中的核心切换程序时，会直接加载另一个应用



**进程的创建：**

**并发：**看起来像同时执行，但是在单核中是因为CPU来回切换程序而实现的并发

**并行：**在多核的CPU中，每个核心同时执行程序

无论是进程还是线程，都只是一个任务而已，

创建一个进程，由应用程序发起，告知操作系统：

1、unix系统是fork，创建子进程时，把父进程的数据内容完整拷贝给子进程，和父进程一样

2、windows系统是creatrpocess，创建子进程时，父进程也会拷贝数据，但内容不一样

**进程的状态：**

1、运行，占用CPU

2、阻塞，遇到IO操作，或优先级更高的程序使用CPU，运行时间过长

3、就绪，时刻准备着被执行

```python
Process([group [, target [, name [, args [, kwargs]]]]])

#group参数未使用，值始终为None

#target表示调用对象，即子进程要执行的任务

#args表示调用对象的位置参数元组，args=(1,2,'egon',)

#kwargs表示调用对象的字典,kwargs={'name':'egon','age':18}

#name为子进程的名称
```

```python
#开启子进程的方式一，通过创建Process对象的方式实现， multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数）
import time

from multiprocessing import Process

def task(name):
    print('%s is running'%name)
    time.sleep(2)
    print('%s is done'%name)

if __name__ == '__main__':
    # 也可以在创建Process对象的时候使用字典的形式传入参数
    # p = Process(target = task,kwargs = {'name':'子进程1'})
    # args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号
    p = Process(target = task,args = ('子进程1',))
    p.start()
    
    print('主')
```

```python
#开启子进程的方式二，通过继承Process类实现
import time
from multiprocessing import Process

class MyProcess(Process):
    def __init__(self,name):
        super(MyProcess,self).__init__()
        self.name = name

    #方法名必须写为run
    def run(self):
        print('%s is running'%self.name)
        time.sleep(2)
        print('%s is done'%self.name)

if __name__ == '__main__':
    p = MyProcess('子进程1')
    #start本质调用的就是绑定方法run
    p.start()

    print('主')

#打印 在执行主进程的过程中也执行了子进程:
#主 
#子进程1 is running
#子进程1 is done
```





GIL

Global Interpreter Lock

GIL只是CPython的特性，并不是python的特性

互斥锁的作用是保护不同类型的数据，将并发的进程、线程代码，变为串行去执行，虽然影响了执行效率，但是保证了数据的准确性。

1、GIL互斥锁是添加在python解释器中的，保护的是python解释器中与垃圾回收机制相关的数据，也就是垃圾回收机制的线程与内存中的其他线程一同去申请GIL锁，执行各自的工作代码
2、实例化Lock的mutex互斥锁，是添加在自己开发的代码中的，保护自己代码中的数据

![GIL工作流程](/Users/wangxin/Documents/wxPythonCode/wxPythonCode/Note/网络编程进阶/GIL工作流程.png)



如图：

1、执行python程序，在内存中开启了一个进程，申请得到一块儿内存空间

2、进程中的主线程，开启了2个子线程去执行各自的工作

3、子线程1申请并得到了GIL解释器锁，才可以通过python解释器的去执行python代码

4、解释器调用操作系统原生的线程，将子线程1分配到CPU的内核1中去执行

5、但是由于子线程1的运行时间较长，被操作系统要求释放GIL锁

6、此时子线程2申请并得到了GIL锁，也开始了自己的代码逻辑

7、当执行完成了自己的代码逻辑，释放了GIL锁

8、由于子线程1，并没有执行完自己的代码逻辑，于是又申请得到了GIL锁，继续执行代码逻辑

9、再次开始时，是从步骤2去重新开始的，而只有在步骤1中才能得到内存中的初始变量count，所以GIL锁并没有保护到程序员开发代码的数据

10、最后子线程1去执行并完成了自己的代码工作，最后释放了GIL锁

所以在多线程申请mutex锁或GIL锁时，有很多无用工作，这就是python2升级至python3中要解决的问题

**所以：**

有了GIL后，在python开启进程的所有线程中，它们只能去申请GIL锁才能去执行各自的代码，也只能被分配带一个CPU内核上，如果想要并行去执行所有线程的代码，那么就只能去使用进程，但是进程的开销又很大

**解释器的运行逻辑：**

在内存中，加载了python解释器的代码，也加载了要执行的python代码，实际上是将python代码以参数的形式传递给python解释器去执行，调用的是C语言去执行底层代码。

在开启的进程的所有线程中，不仅包含执行代码逻辑的主线程还有垃圾回收机器的线程，但是他们都需要调用解释器的代码去执行各自的工作，所以通过GIL锁加载在解释器的代码之中，哪个线程抢到锁，就执行自己的代码

1、在Cpython中如果想要用CPU的多核，就需要开多个进程
2、垃圾回收线程不是一直存在，而是定期会启动进行垃圾回收
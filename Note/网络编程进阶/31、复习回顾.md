**进程复习回顾：**

**1、开启进程的2种方式**

1.1、实例化Process类，通过target指定执行函数，args传入参数

1.2、定义类，并继承于Process类，类中准备执行的函数名必须为run，实例化定义类的对象后，可通过start()方法执行run()方法

**2、进程的其他方法：**

```
os.getpid

os.getppid

p.pid

p.name

p.terminate

p.join
```

**3、守护进程**

常规现象：子进程不会随着主进程结束而结束，而是主进程执行完毕后，会等待子进程执行完毕

守护进程：当主进程执行完毕后，子进程也随之而结束

**4、互斥锁**

Lock()，通过实例化的mutex对象执行acquire()和release()方法，只有得到互斥锁的进程，才能执行函数，保证了同一时间内只有一个进程执行固定的方法

**5、进程间是相互隔离的**，所以数据是独立

**6、基于进程实现套接字并发**，每当通过while循环accept()方法获取到了客户端的conn和caddr，那么就生成创建一个Process对象，去执行start()收发信息的方法

**7、Queue**：每个进程之间的内存数据是相互独立的、隔离的，所以无法互通数据，所以可以通过Queue模块，去发送数据给其他进程，一个进程通过put方法放入数据，其他进程通过get方法取得数据

方法：

put()放入数据

get()取出数据，

q = Queue(3)，一次只能放入3个数据，再次放入，如果没有被get取出，就会在原地等待

JoinableQueue，增加q.task_done方法，通知q.join方法执行后面的代码



**线程复习回顾：**

开进程耗费的资源比线程大很多，因为开启进程，都要去开创一块儿内存空间

同一个进程内可以开启多个线程，它们共享一块内存资源

**1、开启线程的方式**

1.1、实例化Thread类，通过target指定函数，args指定参数，运行start()方法执行函数

1.2、自定义类，继承Thread类，通过start()方法执行定义类中的run方法

**2、区别**

进程的开销比线程大，因为需要开辟内存空间

进程间内存是隔离，相互独立的，线程间内存数据是共享的

进程的PID是不同，线程的PID是同一个

**3、Thread方法**

3.1、getName()方法，默认线程名：Thread-1导入current_thread类下的方法，进程没有此方法

3.2、setName()，t.setName(’子线程‘)来设置线程名

3.3、is_alive()，判断线程是否存活，输出True或False，进程也有该方法

3.4、active_count，首先需要导入active_count，然后调用active_count()即可查看当前活动的线程数

3.5、enumerate，首先需要导入enumerate，然后调用enumerate()方法即可以列表查看当前活动的线程对象

**4、线程的守护进程**

无论是主进程还是主线程，都会等到所有的子进程或子线程执行完毕后，才会结束，所以需要设置守护进程、线程，让他们随着主进程执行完毕后，一起结束

而且都是通过xxx.daemon = True来让指定的子进程或线程一起随着主结束而结束

**5、线程互斥锁**

与进程互斥锁一致，通过实例化Lock()得到对象mutex，通过acquire()和release()方法获取互斥锁和释放互斥锁，且只有得到互斥锁的线程才能执行代码

**6、GIL锁**

就是python解释器的一把锁，只有申请到的代码才能执行代码逻辑，例如我们编写的代码和垃圾回收机制代码，谁申请到谁就可以去执行代码工作

**7、计算密集型使用多进程，读写密集型使用多线程**

**8、死锁**

就是全局互斥锁mutexA和mutexB，在不同的函数中调用时，由于没有及时释放，导致不能acquire到，于是程序卡住一直等待，形成死锁

**9、递归锁**

所以为了解决死锁的问题，使用递归锁，也就是一把可以acquire多次的互斥锁，只有被release，计数器变为0的时候才能被其他线程得到，也就是将程序变成了串行执行

**10、信号量**

也是一把锁，可以设置同时可以有多少线程申请到锁，并执行代码，说白了就是可以设置并发线程数

with mutex:可以代替acquire和release

**11、Event**

通过event.wait()等待event.set发送通知，去执行后面的代码，还可以通过event.is_set()去判断是否执行了event.set()

**12、Timer**

定时器，通过Timer(interval = 5,function = task)实例化对象t，通过start()开启线程每隔xx秒去执行某个函数，调用包含定时器的函数，函数内自身调用自身，来实现

**13、线程queue**

13.1、通过put()和get()放入数据和取出数据，queue()没有设置数量时，可以一次放入多个数据，如何设置了数量，意味着一次只能put几个数据，只有再被get后才能再次put进数据

13.2、阻塞状态默认为block = True，开启状态，如果满了则在原地等待，只有被get取出后才可以继续放入；设置为False后，满了再放就会报错，queue.Full

13.3、当block = True时，timeout参数才生效，是等待多少秒后再放入，但是如果满了，就会报错

13.4、put_nowait()和get_nowait()相当于put和get

13.5、后进先出，实例化对象变为q = queue.LifoQueue()

13.6、按优先级，实例化对象变为q = queue.Priority()，put变为q.put((1,'first'))，增加了一个括号，数值越小优先级越高，被先get

13.7、q.qsize()，显示当前放入了多少数据

**14、进程、线程池**

14.1、都是通过concurrent.futures导入ProcessPoolExecutor或ThredPoolExecutor类

14.2、进程池/线程池数量，如果设置了数量，那么服务端只能开启对应数量的进程或线程，如果没有设置数量，就为CPU的核心数

14.3、通过submit异步提交，开启进程

14.4、pool.map(task,range(10))，执行循环

**15、同步与异步提交**

15.1、同步提交：submit开启进程或线程后，通过result()方法得到执行函数的return结果，将结果传入另一个函数，进行处理，也就是同步提交是等待一个任务执行完成后，得到结果再去执行另一个任务

15.2、异步提交&回调函数：pool.submit(view_html,i)将执行的函数，和参数执行异步提交，不等待程序的返回结果，提交后将得到的结果通过pool.submit(view_html,i).**add_done_callback**(get_size)回调函数自动传入get_size函数中，此时传入的是futures对象，在get_size中可以通过url_obj.result()得到结果

15.3、通过异步提交实现套接字时，每当通过accept()方法获取到客户端连接时，就通过submit()方法执行收发信息的函数任务



基于线程开发一个FTP服务器

1.在之前开发的FTP基础上，开发支持多并发的功能

2.不能使用SocketServer模块，必须自己实现多线程

3.必须用到队列Queue模块，实现线程池

4.允许配置最大并发数，比如允许只有10个并发用户
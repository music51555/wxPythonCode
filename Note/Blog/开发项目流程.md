1、了解需求

​	1) 登录，基于用户认证组件和Ajax登录验证（图片验证码）

​	2) 基于froms组件和Ajax实现注册功能

​	3) 设计系统首页(文章列表渲染)

​	4) 设计个人站点页面

​	5) 文章详情页

​	6) 实现文章点赞

​	7) 实现文章评论，包括文章的评论，评论的评论

​	8) 富文本编辑框和放置xss攻击

2、设计表结构

**用户表：**

```python
from django.contrib.auth.models import AbstractUser

# 用户信息表。继承的AbstractUser类，本身就已经包含了username、password、email等字段，再额外的添加一些自定义的字段，实现自定义用户表，作为用户的接口表
class UserInfo(AbstractUser):
    nid=models.CharField(primary_key=True)
    telephone=models.CharField(max_length=11,null=True,unique=True)
    # 美 /'ævətɑr/ 头像
    avatar=models.FileField(upload_to='avatars/',default='/avatars/default.png')
    # verbose_name指明一个易于理解和表述的对象名称, /vɝ'bos/  冗长的；啰嗦的
    create_time=models.DateTimeField(verbose_name='创建时间',auto_now_add=True)
    # 与Blog表是一对一关系，一对一关系在哪张表中建立关系都是可以的，看更倾向于通过哪张表作为源头去查找
    blog=models.OneToOneField(to='Blog',to_field='nid',null=True)

    def __str__(self):
        return self.username
```



**博客信息表（站点表）：**

```python
class Blog(models.Model):
    # 博客信息表也是站点表，一个用户对应一个博客，这三个属性也可以放在用户表中，但是为了解耦，可以单独存放
    nid=models.CharField(primary_key=True)
    title=models.CharField(verbose_name='个人博客标题',max_length=64)
    site_name=models.CharField(verbose_name='站点名称',max_length=64)
    theme=models.CharField(verbose_name='博客主题',max_length=32)

    def __str__(self):
        return self.title
```



**分类表：**

![1543821550557](.\image\1543821550557.png)

根据用户表去查找**站点表**和**分类表**的关系，一个用户对应多个分类，用户和站点是一对一的关系，所以要创建站点和分类的关系也是一对多关系，在多的表中创建外键

```python
class Category(models.Model):
    # 文章分类表,美 /'kætəɡɔri/ 分类
    nid=models.AutoField(primary_key=True)
    title=models.CharField(verbose_name='分类标题',max_length=32)
    # 根据用户表去查找站点表和分类表的关系，一个用户对应多个分类，用户和站点是一对一的关系，所以要创建站点和分类的关系也是一对多关系，在多的表中创建外键,以后在查询一个用户有哪些分类对象时，可以通过用户表的站点对象去查询所有的分类
    blog=models.ForeignKey(verbose_name='所属博客',to='Blog',to_field='nid')
    
    def __str__(self):
    	return self.title
```



**标签表：**

查找标签和站点的关系，和分类和站点的关系一样

```python
class Tag(models.Model):
    nid=models.AutoField(primary_key=True)
    title=models.CharField(verbose_name='标签名称',max_length=32)
    blog=models.ForeignKey(verbose_name='所属博客',to='Blog',to_field='nid')

    def __str__(self):
        return self.title
```



**文章表：**

```python
class Article(models.Model):
    # 基础字段
    nid=models.AutoField(primary_key=True)
    title=models.CharField(verbose_name='文章标题',max_length=50)
    desc=models.CharField(verbose_name='文章描述',max_length=255)
    create_time=models.DateTimeField(verbose_name='创建时间',auto_now_add=True)
    content=models.TextField()

    # 与用户的关系，一个用户对应多篇文章，一篇文章对应一个用户，多对多关系在多的表中创建关系
    user=models.ForeignKey(verbose_name='作者',to='UserInfo',to_field='nid',null=True)
    # 与分类的关系，一个分类对应多篇文章，一篇文章对应一个分类
    category=models.ForeignKey(to='Category',to_field='nid',null=True)
    # 与标签的关系，一个标签对应多篇文章，一篇文章对应多个标签
    tags=models.ManyToManyField(
        to=Tag,
        # 中间模型，不自动生成多对多关系表，使用手动创建的关系表
        through='Article2Tag',
        through_fields='nid'
    )
```



**文章和标签关系表：**

```python
class Article2Tag(models.Model):
    nid=models.AutoField(primary_key=True)
    article=models.ForeignKey(to='Article',to_field='nid')
    tags=models.ForeignKey(to='Tag',to_field='nid')

    class Meta:
        # 固定的联合为一列表变量名
        unique_together = [
            # 联合唯一，一篇文章不能对应重复标签
            ('article','tags')
        ]

    def __str__(self):
        # 返回article对象的title属性
        return self.article.title+'--'+self.tags.title
```



**点赞表：**

```python
class ArticleUpDown(models.Model):
    nid=models.AutoField(primary_key=True)
    user=models.ForeignKey(to='UserInfo',to_field='nid',null=True)
    article=models.ForeignKey(to='Article',to_field='nid',null=True)
    is_up=models.BooleanField(default=True)

    class Meta:
        unique_together=[
            # 联合唯一，不允许同一用户对同一篇文章重复点赞
            ('user','article'),
        ]
```





```python
Blog
nid
博客信息表也是站点表，一个用户对应一个博客，这三个属性也可以放在用户表中，但是为了解耦，可以单独存放
title Char verbose_name='个人博客标题' max64
site_name Char '站点名称' 64
theme Char '博客主题' 32
return title

一个用户对应一个站点  user  =  blog
且，一个用户对应多个分类
所以，一个站点也是对应多个分类，在多的表中创建外键

Category
博客文章分类
nid
title 分类标题 max_length=32
blog ForeignKey 所属博客 to Blog to_filed=nid



nid
title 文章标题 max50
desc 文章描述 max255
create_time 创建时间 auto_now_add=True
content=TextField

一个用户对应多篇文章，一篇文章对应一个作者
user foreignkey 作者 to userinfo tofied nid

分类和文章定义为一对多关系，一个分类对应多篇文档，一个文章对应一个分类
category foreignkey to  tofield null=True

标签和文章是多对多关系,through中间模型，不用django创建第三章关系表，使用手动创建的关系表
tags=manytomany to Tag through='Article2Tag' through_fields=('article','tag')

Article2Tag
nid
article foreignkey 文章 to Ariticle to_field nid
tag foreignkey 标签 to Tag to_field nid
class Meta:
    unique_together = [
        联合唯一
        ('article','tag'),
    ]
return title+tag


点赞表
ArticleUpDown
nid 
user null True
article null True
is_up BooleanField(defaule=True)

class Meta:
    unique_together=[
        # 联合唯一，不允许一个用户对同一篇文章重复点赞
        ('article','user'),
    ]
```





3、开发功能
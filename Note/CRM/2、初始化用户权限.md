**项目和应用`templates`文件夹查找顺序**

在`views.py`视图函数中，返回`html`模板文件时，`templates`文件夹是依次从项目下至已注册应用的顺序去查找的



**`permission__isnull`:**

在`ORM`语句中，可以使用`permission__isnull = False`去筛选不为空的记录

```python
url_list = UserInfo.objects.filter(        name=request.POST.get('name'),roles__permissions__isnull=False).values_list('roles__permissions__url').distinct()
```



**列表生成式**

由

```python
permission_list = []
for item in permission_queryset:
	url = item['permission_url']
	permission_list.append(url)
```

简化成列表生成式

```python
permission_list = [ item['permission_url'] for item in permission_queryset]
```



**设置`mysql`数据库模式**

在`django`中通过`python3 manage.py makemigrations`时创建表，**会报错或警告**，这是因为`mysql`数据库开启的严格模式，关闭该模式后即可，修改后**重启`mysql`服务**	

```
SET @@global.sql_mode= '';
```



**验证用户登录的用户名和密码正确性：**

1、通过`auth`模块去验证用户名密码是否登录，在使用`auth`模块的`auth.authenticate`方法去验证用户名和密码时，在创建表类时，必须继承于`AbstractUser`

2、尝试了使用全局钩子去校验用户名和密码，但是由于创建`UserInfo`表接口时，继承了`AbstractUser`类，导致存储的密码都是经过加密的，所以直接通过全局钩子去校验总是提示用户名或密码错误

正确的做法是：

通过`forms`组件可以初始化登录或注册页面的表单

通过`forms`组件可以校验单一或多个字段所填写的内容，如用户是否存在，密码和确认密码是否一致等

但是如果要校验登录的用户名和密码是否正确，就一定要使用`auth`模块



**关于`AbstractUser`**

继承`AbstractUser`后，无需再创建`username`、`password`等变量，该类中已经定义好了，在创建超级用户时`python3 manage.py createsuperuser`，会在终端中依次使用定义变量中的`verbose_name`来依次写入用户信息

```shell
python3 manage.py createsuperuser
Username: root
# username和password是Abstract类中定义好的，所以没写verbose_name，而邮箱是自己定义的，添加verbose_name参数，所以是中文
邮箱: root@163.com
Password: 
Password (again): 
Superuser created successfully.
```



**验证用户是否已登录**

调用`request.user.is_authenticated`，返回`True`或`False`



**正则表达式的`^$`**

使用正则表达式匹配数据时，一定要添加`^$`，表示匹配开头和匹配结尾，否则如果较长的字符串中包含了`/customer/list/`，那么也会被认为匹配成功

```
如
/customer/list/
/customer/list/asdsad
```



**正则表达式`search`和`match`的区别**

 `search`会扫描整个`string`查找匹配；

`match`只有在0位置匹配成功的话才有返回，

如果不是开始位置匹配成功的话，`match`就返回`none`。



**在`settings.py`中定义公共变量：**

在`django`项目中，如果变量或者`key`使用次数很多的话，可以将其写在`settings.py`中，引入`settings`后调用



**`static`配置**

在`settings.py`中设置：

```python
STATIC_URL = '/static/'
# 如果此处写为STATIC_DIRS，那么就是{% load static %}
# 如果写为STATICFILES_DIRS，那么就是{% load staticfiles %}
STATIC_DIRS = os.path.join(BASE_DIR,'static')
```

在`html`文件中编写：

```python
# 先加载static
{% load static %}
<link rel="stylesheet" href="{% static '/plugins/bootstrap/css/bootstrap.css' %}">

# 如果设置了DEBUG = True那么static就会失效
DEBUG = False
```





**如何实现动态菜单加载的思路：**

根据登录用户的权限列表，在对应的一级菜单下展示权限列表中URL对应的中文菜单，如有两个一级菜单，有哪些权限的URL就让其显示在对应的一级菜单下

如何实现动态加载一级和二级菜单？

![image-20190307231535285](./images/动态菜单加载.png)



null=True

表示数据库存储数据时，数据库允许为空



blank=True

表示在django后台admin页面中操作数据时，可以写为空